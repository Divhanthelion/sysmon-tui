{"$message_type":"diagnostic","message":"cannot find type `SystemTimeError` in crate `sysinfo`","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3109,"byte_end":3124,"line_start":96,"line_end":96,"column_start":30,"column_end":45,"is_primary":true,"text":[{"text":"            SysInfo(sysinfo::SystemTimeError),","highlight_start":30,"highlight_end":45}],"label":"not found in `sysinfo`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this struct","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2919,"byte_end":2919,"line_start":89,"line_end":89,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"        use std::io;","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"use std::time::SystemTimeError;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `SystemTimeError`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":3100,"byte_end":3109,"line_start":96,"line_end":96,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"            SysInfo(sysinfo::SystemTimeError),","highlight_start":21,"highlight_end":30}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `SystemTimeError` in crate `sysinfo`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:96:30\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m96\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             SysInfo(sysinfo::SystemTimeError),\n   \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `sysinfo`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this struct\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m89\u001b[0m \u001b[92m+ \u001b[0m        \u001b[92muse std::time::SystemTimeError;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `SystemTimeError`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m96\u001b[0m \u001b[91m- \u001b[0m            SysInfo(\u001b[91msysinfo::\u001b[0mSystemTimeError),\n\u001b[1m\u001b[94m96\u001b[0m \u001b[92m+ \u001b[0m            SysInfo(SystemTimeError),\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`SysmonError` doesn't implement `std::fmt::Display`","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":3173,"byte_end":3184,"line_start":99,"line_end":99,"column_start":36,"column_end":47,"is_primary":true,"text":[{"text":"        impl std::error::Error for SysmonError {}","highlight_start":36,"highlight_end":47}],"label":"unsatisfied trait bound","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `std::fmt::Display` is not implemented for `SysmonError`","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":3030,"byte_end":3050,"line_start":94,"line_end":94,"column_start":9,"column_end":29,"is_primary":true,"text":[{"text":"        pub enum SysmonError {","highlight_start":9,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `std::error::Error`","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234/library/core/src/error.rs","byte_start":2024,"byte_end":2056,"line_start":59,"line_end":59,"column_start":1,"column_end":33,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: `SysmonError` doesn't implement `std::fmt::Display`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:99:36\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m99\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         impl std::error::Error for SysmonError {}\n   \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munsatisfied trait bound\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the trait `std::fmt::Display` is not implemented for `SysmonError`\n  \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:94:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m94\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         pub enum SysmonError {\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `std::error::Error`\n  \u001b[1m\u001b[94m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234/library/core/src/error.rs:59:1\n\n"}
{"$message_type":"diagnostic","message":"this method takes 1 argument but 0 arguments were supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":2106,"byte_end":2108,"line_start":57,"line_end":57,"column_start":43,"column_end":45,"is_primary":false,"text":[{"text":"                        app.update_metrics();","highlight_start":43,"highlight_end":45}],"label":"argument #1 of type `&mut Collector` is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":2092,"byte_end":2106,"line_start":57,"line_end":57,"column_start":29,"column_end":43,"is_primary":true,"text":[{"text":"                        app.update_metrics();","highlight_start":29,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"src/main.rs","byte_start":22916,"byte_end":22941,"line_start":645,"line_end":645,"column_start":17,"column_end":42,"is_primary":false,"text":[{"text":"                collector: &mut Collector,","highlight_start":17,"highlight_end":42}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":22857,"byte_end":22871,"line_start":643,"line_end":643,"column_start":20,"column_end":34,"is_primary":true,"text":[{"text":"            pub fn update_metrics(","highlight_start":20,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":2106,"byte_end":2108,"line_start":57,"line_end":57,"column_start":43,"column_end":45,"is_primary":true,"text":[{"text":"                        app.update_metrics();","highlight_start":43,"highlight_end":45}],"label":null,"suggested_replacement":"(/* &mut Collector */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this method takes 1 argument but 0 arguments were supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:57:29\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         app.update_metrics();\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[94margument #1 of type `&mut Collector` is missing\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:643:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m643\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             pub fn update_metrics(\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m644\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 &mut self,\n\u001b[1m\u001b[94m645\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 collector: &mut Collector,\n    \u001b[1m\u001b[94m|\u001b[0m                 \u001b[1m\u001b[94m-------------------------\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: provide the argument\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m57\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                        app.update_metrics(\u001b[92m/* &mut Collector */\u001b[0m);\n    \u001b[1m\u001b[94m|\u001b[0m                                            \u001b[92m++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no function or associated item named `from_raw` found for struct `KeyEvent` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":5160,"byte_end":5168,"line_start":147,"line_end":147,"column_start":77,"column_end":85,"is_primary":true,"text":[{"text":"                        match event::read().unwrap_or(CEvent::Key(KeyEvent::from_raw(0, 0))) {","highlight_start":77,"highlight_end":85}],"label":"function or associated item not found in `KeyEvent`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if you're trying to build a new `KeyEvent` consider using one of the following associated functions:\nKeyEvent::new\nKeyEvent::new_with_kind\nKeyEvent::new_with_kind_and_state","code":null,"level":"note","spans":[{"file_name":"/Users/rj/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossterm-0.28.1/src/event.rs","byte_start":26643,"byte_end":26711,"line_start":757,"line_end":757,"column_start":5,"column_end":73,"is_primary":true,"text":[{"text":"    pub const fn new(code: KeyCode, modifiers: KeyModifiers) -> KeyEvent {","highlight_start":5,"highlight_end":73}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/rj/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossterm-0.28.1/src/event.rs","byte_start":26886,"byte_end":27019,"line_start":766,"line_end":770,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"    pub const fn new_with_kind(","highlight_start":5,"highlight_end":32},{"text":"        code: KeyCode,","highlight_start":1,"highlight_end":23},{"text":"        modifiers: KeyModifiers,","highlight_start":1,"highlight_end":33},{"text":"        kind: KeyEventKind,","highlight_start":1,"highlight_end":28},{"text":"    ) -> KeyEvent {","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/rj/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossterm-0.28.1/src/event.rs","byte_start":27173,"byte_end":27347,"line_start":779,"line_end":784,"column_start":5,"column_end":18,"is_primary":true,"text":[{"text":"    pub const fn new_with_kind_and_state(","highlight_start":5,"highlight_end":42},{"text":"        code: KeyCode,","highlight_start":1,"highlight_end":23},{"text":"        modifiers: KeyModifiers,","highlight_start":1,"highlight_end":33},{"text":"        kind: KeyEventKind,","highlight_start":1,"highlight_end":28},{"text":"        state: KeyEventState,","highlight_start":1,"highlight_end":30},{"text":"    ) -> KeyEvent {","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"there is an associated function `from` with a similar name","code":null,"level":"help","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234/library/core/src/convert/mod.rs","byte_start":23063,"byte_end":23089,"line_start":592,"line_end":592,"column_start":5,"column_end":31,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no function or associated item named `from_raw` found for struct `KeyEvent` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:147:77\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m147\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         match event::read().unwrap_or(CEvent::Key(KeyEvent::from_raw(0, 0))) {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                             \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mfunction or associated item not found in `KeyEvent`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: if you're trying to build a new `KeyEvent` consider using one of the following associated functions:\n      KeyEvent::new\n      KeyEvent::new_with_kind\n      KeyEvent::new_with_kind_and_state\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/rj/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/crossterm-0.28.1/src/event.rs:757:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m757\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       pub const fn new(code: KeyCode, modifiers: KeyModifiers) -> KeyEvent {\n    \u001b[1m\u001b[94m|\u001b[0m       \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m766\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m     pub const fn new_with_kind(\n\u001b[1m\u001b[94m767\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         code: KeyCode,\n\u001b[1m\u001b[94m768\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         modifiers: KeyModifiers,\n\u001b[1m\u001b[94m769\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         kind: KeyEventKind,\n\u001b[1m\u001b[94m770\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ) -> KeyEvent {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_________________^\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m779\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m/\u001b[0m     pub const fn new_with_kind_and_state(\n\u001b[1m\u001b[94m780\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         code: KeyCode,\n\u001b[1m\u001b[94m781\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         modifiers: KeyModifiers,\n\u001b[1m\u001b[94m782\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         kind: KeyEventKind,\n\u001b[1m\u001b[94m783\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m         state: KeyEventState,\n\u001b[1m\u001b[94m784\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|\u001b[0m     ) -> KeyEvent {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[92m|_________________^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is an associated function `from` with a similar name\n   \u001b[1m\u001b[94m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234/library/core/src/convert/mod.rs:592:5\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7965,"byte_end":7970,"line_start":240,"line_end":240,"column_start":21,"column_end":26,"is_primary":true,"text":[{"text":"                    Ok(_) => {}","highlight_start":21,"highlight_end":26}],"label":"expected `()`, found `Result<_, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":7920,"byte_end":7942,"line_start":239,"line_end":239,"column_start":23,"column_end":45,"is_primary":false,"text":[{"text":"                match self.sys.refresh_all() {","highlight_start":23,"highlight_end":45}],"label":"this expression has type `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected unit type `()`\n        found enum `Result<_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:240:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m239\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 match self.sys.refresh_all() {\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94m----------------------\u001b[0m \u001b[1m\u001b[94mthis expression has type `()`\u001b[0m\n\u001b[1m\u001b[94m240\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     Ok(_) => {}\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `()`, found `Result<_, _>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected unit type `\u001b[1m\u001b[35m()\u001b[0m`\n                    found enum `\u001b[1m\u001b[35mResult<_, _>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":7997,"byte_end":8003,"line_start":241,"line_end":241,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"                    Err(e) => return Err(crate::errors::SysmonError::SysInfo(e)),","highlight_start":21,"highlight_end":27}],"label":"expected `()`, found `Result<_, _>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":7920,"byte_end":7942,"line_start":239,"line_end":239,"column_start":23,"column_end":45,"is_primary":false,"text":[{"text":"                match self.sys.refresh_all() {","highlight_start":23,"highlight_end":45}],"label":"this expression has type `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected unit type `()`\n        found enum `Result<_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:241:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m239\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 match self.sys.refresh_all() {\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[94m----------------------\u001b[0m \u001b[1m\u001b[94mthis expression has type `()`\u001b[0m\n\u001b[1m\u001b[94m240\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     Ok(_) => {}\n\u001b[1m\u001b[94m241\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     Err(e) => return Err(crate::errors::SysmonError::SysInfo(e)),\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `()`, found `Result<_, _>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected unit type `\u001b[1m\u001b[35m()\u001b[0m`\n                    found enum `\u001b[1m\u001b[35mResult<_, _>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"no method named `processors` found for struct `sysinfo::System` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8138,"byte_end":8189,"line_start":245,"line_end":247,"column_start":27,"column_end":22,"is_primary":false,"text":[{"text":"                let cpu = self","highlight_start":27,"highlight_end":31},{"text":"                    .sys","highlight_start":1,"highlight_end":25},{"text":"                    .processors()","highlight_start":1,"highlight_end":22}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":8189,"byte_end":8199,"line_start":247,"line_end":247,"column_start":22,"column_end":32,"is_primary":true,"text":[{"text":"                    .processors()","highlight_start":22,"highlight_end":32}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"there is a method `process` with a similar name, but with different arguments","code":null,"level":"help","spans":[{"file_name":"/Users/rj/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sysinfo-0.38.1/src/common/system.rs","byte_start":14635,"byte_end":14686,"line_start":423,"line_end":423,"column_start":5,"column_end":56,"is_primary":true,"text":[{"text":"    pub fn process(&self, pid: Pid) -> Option<&Process> {","highlight_start":5,"highlight_end":56}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `processors` found for struct `sysinfo::System` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:247:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m245\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                   let cpu = self\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ___________________________-\u001b[0m\n\u001b[1m\u001b[94m246\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .sys\n\u001b[1m\u001b[94m247\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .processors()\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: there is a method `process` with a similar name, but with different arguments\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/rj/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sysinfo-0.38.1/src/common/system.rs:423:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m423\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn process(&self, pid: Pid) -> Option<&Process> {\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed for `(usize, _)`","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":8408,"byte_end":8412,"line_start":252,"line_end":252,"column_start":40,"column_end":44,"is_primary":false,"text":[{"text":"                        usage_percent: proc.cpu_usage(),","highlight_start":40,"highlight_end":44}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":8289,"byte_end":8300,"line_start":250,"line_end":250,"column_start":27,"column_end":38,"is_primary":true,"text":[{"text":"                    .map(|(idx, proc)| crate::types::CpuCoreUsage {","highlight_start":27,"highlight_end":38}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type, where the placeholders `_` are specified","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":8300,"byte_end":8300,"line_start":250,"line_end":250,"column_start":38,"column_end":38,"is_primary":true,"text":[{"text":"                    .map(|(idx, proc)| crate::types::CpuCoreUsage {","highlight_start":38,"highlight_end":38}],"label":null,"suggested_replacement":": (_, _)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed for `(usize, _)`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:250:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m250\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .map(|(idx, proc)| crate::types::CpuCoreUsage {\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m\n\u001b[1m\u001b[94m251\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         core_id: idx,\n\u001b[1m\u001b[94m252\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         usage_percent: proc.cpu_usage(),\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type, where the placeholders `_` are specified\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m250\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                    .map(|(idx, proc)\u001b[92m: (_, _)\u001b[0m| crate::types::CpuCoreUsage {\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[92m++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `networks` found for struct `sysinfo::System` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9097,"byte_end":9105,"line_start":271,"line_end":271,"column_start":47,"column_end":55,"is_primary":true,"text":[{"text":"                for (_name, data) in self.sys.networks() {","highlight_start":47,"highlight_end":55}],"label":"method not found in `sysinfo::System`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `networks` found for struct `sysinfo::System` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:271:47\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m271\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for (_name, data) in self.sys.networks() {\n    \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `sysinfo::System`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9142,"byte_end":9146,"line_start":272,"line_end":272,"column_start":33,"column_end":37,"is_primary":true,"text":[{"text":"                    net_recv += data.received();","highlight_start":33,"highlight_end":37}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:272:33\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m272\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     net_recv += data.received();\n    \u001b[1m\u001b[94m|\u001b[0m                                 \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `disks` found for struct `sysinfo::System` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9566,"byte_end":9571,"line_start":283,"line_end":283,"column_start":38,"column_end":43,"is_primary":true,"text":[{"text":"                for disk in self.sys.disks() {","highlight_start":38,"highlight_end":43}],"label":"method not found in `sysinfo::System`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `disks` found for struct `sysinfo::System` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:283:38\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m283\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 for disk in self.sys.disks() {\n    \u001b[1m\u001b[94m|\u001b[0m                                      \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `sysinfo::System`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":9609,"byte_end":9613,"line_start":284,"line_end":284,"column_start":34,"column_end":38,"is_primary":true,"text":[{"text":"                    disk_read += disk.read_bytes();","highlight_start":34,"highlight_end":38}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:284:34\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m284\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     disk_read += disk.read_bytes();\n    \u001b[1m\u001b[94m|\u001b[0m                                  \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `to_string` exists for reference `&OsStr`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":10133,"byte_end":10142,"line_start":298,"line_end":298,"column_start":46,"column_end":55,"is_primary":true,"text":[{"text":"                        name: process.name().to_string(),","highlight_start":46,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`OsStr: std::fmt::Display`\nwhich is required by `OsStr: ToString`\n`&OsStr: std::fmt::Display`\nwhich is required by `&OsStr: ToString`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `to_string` exists for reference `&OsStr`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:298:46\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m298\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                         name: process.name().to_string(),\n    \u001b[1m\u001b[94m|\u001b[0m                                              \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `OsStr: std::fmt::Display`\n            which is required by `OsStr: ToString`\n            `&OsStr: std::fmt::Display`\n            which is required by `&OsStr: ToString`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `SparklineBar: From<&u16>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":14546,"byte_end":14555,"line_start":429,"line_end":429,"column_start":27,"column_end":36,"is_primary":true,"text":[{"text":"                    .data(&data_u16)","highlight_start":27,"highlight_end":36}],"label":"the trait `From<&u16>` is not implemented for `SparklineBar`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":14541,"byte_end":14545,"line_start":429,"line_end":429,"column_start":22,"column_end":26,"is_primary":false,"text":[{"text":"                    .data(&data_u16)","highlight_start":22,"highlight_end":26}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  `SparklineBar` implements `From<&Option<u64>>`\n  `SparklineBar` implements `From<&u64>`\n  `SparklineBar` implements `From<Option<u64>>`\n  `SparklineBar` implements `From<u64>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&u16` to implement `Into<SparklineBar>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `Sparkline::<'a>::data`","code":null,"level":"note","spans":[{"file_name":"/Users/rj/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ratatui-0.29.0/src/widgets/sparkline.rs","byte_start":8059,"byte_end":8063,"line_start":205,"line_end":205,"column_start":12,"column_end":16,"is_primary":false,"text":[{"text":"    pub fn data<T>(mut self, data: T) -> Self","highlight_start":12,"highlight_end":16}],"label":"required by a bound in this associated function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/rj/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ratatui-0.29.0/src/widgets/sparkline.rs","byte_start":8146,"byte_end":8164,"line_start":208,"line_end":208,"column_start":18,"column_end":36,"is_primary":true,"text":[{"text":"        T::Item: Into<SparklineBar>,","highlight_start":18,"highlight_end":36}],"label":"required by this bound in `Sparkline::<'a>::data`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `SparklineBar: From<&u16>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:429:27\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m429\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .data(&data_u16)\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `From<&u16>` is not implemented for `SparklineBar`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `From<T>`:\n              `SparklineBar` implements `From<&Option<u64>>`\n              `SparklineBar` implements `From<&u64>`\n              `SparklineBar` implements `From<Option<u64>>`\n              `SparklineBar` implements `From<u64>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&u16` to implement `Into<SparklineBar>`\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `Sparkline::<'a>::data`\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/rj/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ratatui-0.29.0/src/widgets/sparkline.rs:208:18\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m205\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn data<T>(mut self, data: T) -> Self\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this associated function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m208\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         T::Item: Into<SparklineBar>,\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Sparkline::<'a>::data`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Text<'_>: From<&String>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":17798,"byte_end":17802,"line_start":512,"line_end":512,"column_start":29,"column_end":33,"is_primary":true,"text":[{"text":"                            Cell::from(&p.name),","highlight_start":29,"highlight_end":33}],"label":"the trait `From<&String>` is not implemented for `Text<'_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `From<T>`:\n  `Text<'_>` implements `From<&Masked<'_>>`\n  `Text<'_>` implements `From<&str>`\n  `Text<'_>` implements `From<Cow<'_, str>>`\n  `Text<'_>` implements `From<Masked<'_>>`\n  `Text<'_>` implements `From<Span<'_>>`\n  `Text<'_>` implements `From<String>`\n  `Text<'_>` implements `From<Vec<ratatui::prelude::Line<'_>>>`\n  `Text<'_>` implements `From<ratatui::prelude::Line<'_>>`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `&String` to implement `Into<Text<'_>>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `ratatui::widgets::Cell<'_>` to implement `From<&String>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Text<'_>: From<&String>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:512:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m512\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m...\u001b[0m                   Cell::from(&p.name),\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `From<&String>` is not implemented for `Text<'_>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `From<T>`:\n              `Text<'_>` implements `From<&Masked<'_>>`\n              `Text<'_>` implements `From<&str>`\n              `Text<'_>` implements `From<Cow<'_, str>>`\n              `Text<'_>` implements `From<Masked<'_>>`\n              `Text<'_>` implements `From<Span<'_>>`\n              `Text<'_>` implements `From<String>`\n              `Text<'_>` implements `From<Vec<ratatui::prelude::Line<'_>>>`\n              `Text<'_>` implements `From<ratatui::prelude::Line<'_>>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `&String` to implement `Into<Text<'_>>`\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `ratatui::widgets::Cell<'_>` to implement `From<&String>`\n\n"}
{"$message_type":"diagnostic","message":"this function takes 2 arguments but 1 argument was supplied","code":{"code":"E0061","explanation":"An invalid number of arguments was passed when calling a function.\n\nErroneous code example:\n\n```compile_fail,E0061\nfn f(u: i32) {}\n\nf(); // error!\n```\n\nThe number of arguments passed to a function must match the number of arguments\nspecified in the function signature.\n\nFor example, a function like:\n\n```\nfn f(a: u16, b: &str) {}\n```\n\nMust always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n\nNote that Rust does not have a notion of optional function arguments or\nvariadic functions (except for its C-FFI).\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":18114,"byte_end":18120,"line_start":519,"line_end":519,"column_start":39,"column_end":45,"is_primary":false,"text":[{"text":"                let table = Table::new(rows)","highlight_start":39,"highlight_end":45}],"label":"argument #2 is missing","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":18104,"byte_end":18114,"line_start":519,"line_end":519,"column_start":29,"column_end":39,"is_primary":true,"text":[{"text":"                let table = Table::new(rows)","highlight_start":29,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"associated function defined here","code":null,"level":"note","spans":[{"file_name":"/Users/rj/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ratatui-0.29.0/src/widgets/table/table.rs","byte_start":11334,"byte_end":11337,"line_start":325,"line_end":325,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"    pub fn new<R, C>(rows: R, widths: C) -> Self","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"provide the argument","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":18114,"byte_end":18120,"line_start":519,"line_end":519,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"                let table = Table::new(rows)","highlight_start":39,"highlight_end":45}],"label":null,"suggested_replacement":"(rows, /* widths */)","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0061]\u001b[0m\u001b[1m: this function takes 2 arguments but 1 argument was supplied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:519:29\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m519\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let table = Table::new(rows)\n    \u001b[1m\u001b[94m|\u001b[0m                             \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m\u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94margument #2 is missing\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: associated function defined here\n   \u001b[1m\u001b[94m--> \u001b[0m/Users/rj/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/ratatui-0.29.0/src/widgets/table/table.rs:325:12\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m325\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn new<R, C>(rows: R, widths: C) -> Self\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: provide the argument\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m519\u001b[0m \u001b[1m\u001b[94m| \u001b[0m                let table = Table::new(rows\u001b[92m, /* widths */\u001b[0m)\n    \u001b[1m\u001b[94m|\u001b[0m                                            \u001b[92m++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected an array or slice, found `Rc<[Rect]>`","code":{"code":"E0529","explanation":"An array or slice pattern was matched against some other type.\n\nExample of erroneous code:\n\n```compile_fail,E0529\nlet r: f32 = 1.0;\nmatch r {\n    [a, b] => { // error: expected an array or slice, found `f32`\n        println!(\"a={}, b={}\", a, b);\n    }\n}\n```\n\nEnsure that the pattern and the expression being matched on are of consistent\ntypes:\n\n```\nlet r = [1.0, 2.0];\nmatch r {\n    [a, b] => { // ok!\n        println!(\"a={}, b={}\", a, b);\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":19764,"byte_end":19777,"line_start":562,"line_end":562,"column_start":21,"column_end":34,"is_primary":true,"text":[{"text":"                let [top, bottom] = Layout::default()","highlight_start":21,"highlight_end":34}],"label":"pattern cannot match with input type `Rc<[Rect]>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0529]\u001b[0m\u001b[1m: expected an array or slice, found `Rc<[Rect]>`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:562:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m562\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let [top, bottom] = Layout::default()\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mpattern cannot match with input type `Rc<[Rect]>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected an array or slice, found `Rc<[Rect]>`","code":{"code":"E0529","explanation":"An array or slice pattern was matched against some other type.\n\nExample of erroneous code:\n\n```compile_fail,E0529\nlet r: f32 = 1.0;\nmatch r {\n    [a, b] => { // error: expected an array or slice, found `f32`\n        println!(\"a={}, b={}\", a, b);\n    }\n}\n```\n\nEnsure that the pattern and the expression being matched on are of consistent\ntypes:\n\n```\nlet r = [1.0, 2.0];\nmatch r {\n    [a, b] => { // ok!\n        println!(\"a={}, b={}\", a, b);\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":20071,"byte_end":20091,"line_start":568,"line_end":568,"column_start":21,"column_end":41,"is_primary":true,"text":[{"text":"                let [cpu_area, ram_area] = Layout::default()","highlight_start":21,"highlight_end":41}],"label":"pattern cannot match with input type `Rc<[Rect]>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0529]\u001b[0m\u001b[1m: expected an array or slice, found `Rc<[Rect]>`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:568:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m568\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let [cpu_area, ram_area] = Layout::default()\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mpattern cannot match with input type `Rc<[Rect]>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"expected an array or slice, found `Rc<[Rect]>`","code":{"code":"E0529","explanation":"An array or slice pattern was matched against some other type.\n\nExample of erroneous code:\n\n```compile_fail,E0529\nlet r: f32 = 1.0;\nmatch r {\n    [a, b] => { // error: expected an array or slice, found `f32`\n        println!(\"a={}, b={}\", a, b);\n    }\n}\n```\n\nEnsure that the pattern and the expression being matched on are of consistent\ntypes:\n\n```\nlet r = [1.0, 2.0];\nmatch r {\n    [a, b] => { // ok!\n        println!(\"a={}, b={}\", a, b);\n    }\n}\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":20404,"byte_end":20436,"line_start":574,"line_end":574,"column_start":21,"column_end":53,"is_primary":true,"text":[{"text":"                let [net_area, disk_area, proc_area] = Layout::default()","highlight_start":21,"highlight_end":53}],"label":"pattern cannot match with input type `Rc<[Rect]>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0529]\u001b[0m\u001b[1m: expected an array or slice, found `Rc<[Rect]>`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:574:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m574\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let [net_area, disk_area, proc_area] = Layout::default()\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mpattern cannot match with input type `Rc<[Rect]>`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"use of deprecated method `ratatui::Frame::<'_>::size`: use .area() as it's the more correct name","code":{"code":"deprecated","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":24315,"byte_end":24319,"line_start":674,"line_end":674,"column_start":30,"column_end":34,"is_primary":true,"text":[{"text":"                let size = f.size();","highlight_start":30,"highlight_end":34}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(deprecated)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: use of deprecated method `ratatui::Frame::<'_>::size`: use .area() as it's the more correct name\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:674:30\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m674\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 let size = f.size();\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[33m^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(deprecated)]` on by default\n\n"}
{"$message_type":"diagnostic","message":"the method `clone` exists for struct `Vec<CpuCoreUsage>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":24463,"byte_end":24468,"line_start":678,"line_end":678,"column_start":52,"column_end":57,"is_primary":true,"text":[{"text":"                CpuBarWidget::new(self.metrics.cpu.clone())","highlight_start":52,"highlight_end":57}],"label":"method cannot be called on `Vec<CpuCoreUsage>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":5730,"byte_end":5753,"line_start":165,"line_end":165,"column_start":9,"column_end":32,"is_primary":false,"text":[{"text":"        pub struct CpuCoreUsage {","highlight_start":9,"highlight_end":32}],"label":"doesn't satisfy `CpuCoreUsage: Clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`CpuCoreUsage: Clone`\nwhich is required by `Vec<CpuCoreUsage>: Clone`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider annotating `CpuCoreUsage` with `#[derive(Clone)]`","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":5730,"byte_end":5730,"line_start":165,"line_end":165,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"        pub struct CpuCoreUsage {","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"#[derive(Clone)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `clone` exists for struct `Vec<CpuCoreUsage>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:678:52\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m165\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         pub struct CpuCoreUsage {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-----------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `CpuCoreUsage: Clone`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m678\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 CpuBarWidget::new(self.metrics.cpu.clone())\n    \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `Vec<CpuCoreUsage>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `CpuCoreUsage: Clone`\n            which is required by `Vec<CpuCoreUsage>: Clone`\n\u001b[1m\u001b[96mhelp\u001b[0m: consider annotating `CpuCoreUsage` with `#[derive(Clone)]`\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m165\u001b[0m \u001b[92m+ \u001b[0m        \u001b[92m#[derive(Clone)]\u001b[0m\n\u001b[1m\u001b[94m166\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        pub struct CpuCoreUsage {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `render` found for struct `CpuBarWidget` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":24428,"byte_end":24493,"line_start":678,"line_end":679,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"                CpuBarWidget::new(self.metrics.cpu.clone())","highlight_start":17,"highlight_end":60},{"text":"                    .render(layout.cpu_area, f);","highlight_start":1,"highlight_end":22}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":24493,"byte_end":24499,"line_start":679,"line_end":679,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"                    .render(layout.cpu_area, f);","highlight_start":22,"highlight_end":28}],"label":"method not found in `CpuBarWidget`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11391,"byte_end":11397,"line_start":342,"line_end":342,"column_start":16,"column_end":22,"is_primary":false,"text":[{"text":"            fn render(&self, area: Rect, f: &mut Frame);","highlight_start":16,"highlight_end":22}],"label":"the method is available for `CpuBarWidget` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11505,"byte_end":11528,"line_start":346,"line_end":346,"column_start":9,"column_end":32,"is_primary":false,"text":[{"text":"        pub struct CpuBarWidget {","highlight_start":9,"highlight_end":32}],"label":"method `render` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `Renderable` which provides `render` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21004,"byte_end":21004,"line_start":595,"line_end":595,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"        use crate::errors::SysmonError;","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"use crate::widgets::Renderable;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `render` found for struct `CpuBarWidget` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:679:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               fn render(&self, area: Rect, f: &mut Frame);\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mthe method is available for `CpuBarWidget` here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m346\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           pub struct CpuBarWidget {\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[94m-----------------------\u001b[0m \u001b[1m\u001b[94mmethod `render` not found for this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m678\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m                 CpuBarWidget::new(self.metrics.cpu.clone())\n\u001b[1m\u001b[94m679\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .render(layout.cpu_area, f);\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `CpuBarWidget`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `Renderable` which provides `render` is implemented but not in scope; perhaps you want to import it\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m595\u001b[0m \u001b[92m+ \u001b[0m        \u001b[92muse crate::widgets::Renderable;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `clone` found for struct `RamSwapUsage` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":24610,"byte_end":24615,"line_start":682,"line_end":682,"column_start":54,"column_end":59,"is_primary":true,"text":[{"text":"                RamGaugeWidget::new(self.metrics.ram.clone())","highlight_start":54,"highlight_end":59}],"label":"method not found in `RamSwapUsage`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":5883,"byte_end":5906,"line_start":171,"line_end":171,"column_start":9,"column_end":32,"is_primary":false,"text":[{"text":"        pub struct RamSwapUsage {","highlight_start":9,"highlight_end":32}],"label":"method `clone` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following trait defines an item `clone`, perhaps you need to implement it:\ncandidate #1: `Clone`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `clone` found for struct `RamSwapUsage` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:682:54\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m171\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         pub struct RamSwapUsage {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-----------------------\u001b[0m \u001b[1m\u001b[94mmethod `clone` not found for this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m682\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 RamGaugeWidget::new(self.metrics.ram.clone())\n    \u001b[1m\u001b[94m|\u001b[0m                                                      \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `RamSwapUsage`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is implemented and in scope\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n\n"}
{"$message_type":"diagnostic","message":"no method named `render` found for struct `RamGaugeWidget` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":24573,"byte_end":24640,"line_start":682,"line_end":683,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"                RamGaugeWidget::new(self.metrics.ram.clone())","highlight_start":17,"highlight_end":62},{"text":"                    .render(layout.ram_area, f);","highlight_start":1,"highlight_end":22}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":24640,"byte_end":24646,"line_start":683,"line_end":683,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"                    .render(layout.ram_area, f);","highlight_start":22,"highlight_end":28}],"label":"method not found in `RamGaugeWidget`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11391,"byte_end":11397,"line_start":342,"line_end":342,"column_start":16,"column_end":22,"is_primary":false,"text":[{"text":"            fn render(&self, area: Rect, f: &mut Frame);","highlight_start":16,"highlight_end":22}],"label":"the method is available for `RamGaugeWidget` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":12813,"byte_end":12838,"line_start":382,"line_end":382,"column_start":9,"column_end":34,"is_primary":false,"text":[{"text":"        pub struct RamGaugeWidget {","highlight_start":9,"highlight_end":34}],"label":"method `render` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `Renderable` which provides `render` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21004,"byte_end":21004,"line_start":595,"line_end":595,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"        use crate::errors::SysmonError;","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"use crate::widgets::Renderable;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `render` found for struct `RamGaugeWidget` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:683:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               fn render(&self, area: Rect, f: &mut Frame);\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mthe method is available for `RamGaugeWidget` here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m382\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           pub struct RamGaugeWidget {\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[94m-------------------------\u001b[0m \u001b[1m\u001b[94mmethod `render` not found for this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m682\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m                 RamGaugeWidget::new(self.metrics.ram.clone())\n\u001b[1m\u001b[94m683\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .render(layout.ram_area, f);\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `RamGaugeWidget`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `Renderable` which provides `render` is implemented but not in scope; perhaps you want to import it\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m595\u001b[0m \u001b[92m+ \u001b[0m        \u001b[92muse crate::widgets::Renderable;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `render` found for struct `NetworkSparklineWidget` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":24920,"byte_end":24979,"line_start":690,"line_end":691,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"                NetworkSparklineWidget::new(net_data)","highlight_start":17,"highlight_end":54},{"text":"                    .render(layout.net_area, f);","highlight_start":1,"highlight_end":22}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":24979,"byte_end":24985,"line_start":691,"line_end":691,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"                    .render(layout.net_area, f);","highlight_start":22,"highlight_end":28}],"label":"method not found in `NetworkSparklineWidget`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11391,"byte_end":11397,"line_start":342,"line_end":342,"column_start":16,"column_end":22,"is_primary":false,"text":[{"text":"            fn render(&self, area: Rect, f: &mut Frame);","highlight_start":16,"highlight_end":22}],"label":"the method is available for `NetworkSparklineWidget` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":13786,"byte_end":13819,"line_start":409,"line_end":409,"column_start":9,"column_end":42,"is_primary":false,"text":[{"text":"        pub struct NetworkSparklineWidget {","highlight_start":9,"highlight_end":42}],"label":"method `render` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `Renderable` which provides `render` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21004,"byte_end":21004,"line_start":595,"line_end":595,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"        use crate::errors::SysmonError;","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"use crate::widgets::Renderable;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `render` found for struct `NetworkSparklineWidget` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:691:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               fn render(&self, area: Rect, f: &mut Frame);\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mthe method is available for `NetworkSparklineWidget` here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m409\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           pub struct NetworkSparklineWidget {\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[94m---------------------------------\u001b[0m \u001b[1m\u001b[94mmethod `render` not found for this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m690\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m                 NetworkSparklineWidget::new(net_data)\n\u001b[1m\u001b[94m691\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .render(layout.net_area, f);\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `NetworkSparklineWidget`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `Renderable` which provides `render` is implemented but not in scope; perhaps you want to import it\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m595\u001b[0m \u001b[92m+ \u001b[0m        \u001b[92muse crate::widgets::Renderable;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `clone` found for struct `DiskIOStats` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":25098,"byte_end":25103,"line_start":694,"line_end":694,"column_start":59,"column_end":64,"is_primary":true,"text":[{"text":"                DiskIOBarWidget::new(self.metrics.disk_io.clone())","highlight_start":59,"highlight_end":64}],"label":"method not found in `DiskIOStats`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":6192,"byte_end":6214,"line_start":183,"line_end":183,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        pub struct DiskIOStats {","highlight_start":9,"highlight_end":31}],"label":"method `clone` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following trait defines an item `clone`, perhaps you need to implement it:\ncandidate #1: `Clone`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `clone` found for struct `DiskIOStats` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:694:59\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m183\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         pub struct DiskIOStats {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m----------------------\u001b[0m \u001b[1m\u001b[94mmethod `clone` not found for this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m694\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 DiskIOBarWidget::new(self.metrics.disk_io.clone())\n    \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `DiskIOStats`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is implemented and in scope\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n\n"}
{"$message_type":"diagnostic","message":"no method named `render` found for struct `DiskIOBarWidget` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":25056,"byte_end":25128,"line_start":694,"line_end":695,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"                DiskIOBarWidget::new(self.metrics.disk_io.clone())","highlight_start":17,"highlight_end":67},{"text":"                    .render(layout.disk_area, f);","highlight_start":1,"highlight_end":22}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":25128,"byte_end":25134,"line_start":695,"line_end":695,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"                    .render(layout.disk_area, f);","highlight_start":22,"highlight_end":28}],"label":"method not found in `DiskIOBarWidget`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11391,"byte_end":11397,"line_start":342,"line_end":342,"column_start":16,"column_end":22,"is_primary":false,"text":[{"text":"            fn render(&self, area: Rect, f: &mut Frame);","highlight_start":16,"highlight_end":22}],"label":"the method is available for `DiskIOBarWidget` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":14761,"byte_end":14787,"line_start":436,"line_end":436,"column_start":9,"column_end":35,"is_primary":false,"text":[{"text":"        pub struct DiskIOBarWidget {","highlight_start":9,"highlight_end":35}],"label":"method `render` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `Renderable` which provides `render` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21004,"byte_end":21004,"line_start":595,"line_end":595,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"        use crate::errors::SysmonError;","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"use crate::widgets::Renderable;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `render` found for struct `DiskIOBarWidget` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:695:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               fn render(&self, area: Rect, f: &mut Frame);\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mthe method is available for `DiskIOBarWidget` here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m436\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           pub struct DiskIOBarWidget {\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[94m--------------------------\u001b[0m \u001b[1m\u001b[94mmethod `render` not found for this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m694\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m                 DiskIOBarWidget::new(self.metrics.disk_io.clone())\n\u001b[1m\u001b[94m695\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .render(layout.disk_area, f);\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `DiskIOBarWidget`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `Renderable` which provides `render` is implemented but not in scope; perhaps you want to import it\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m595\u001b[0m \u001b[92m+ \u001b[0m        \u001b[92muse crate::widgets::Renderable;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the method `clone` exists for struct `Vec<ProcessInfo>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":25254,"byte_end":25259,"line_start":698,"line_end":698,"column_start":64,"column_end":69,"is_primary":true,"text":[{"text":"                ProcessTableWidget::new(self.metrics.processes.clone(), self.sort_order)","highlight_start":64,"highlight_end":69}],"label":"method cannot be called on `Vec<ProcessInfo>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":6345,"byte_end":6367,"line_start":189,"line_end":189,"column_start":9,"column_end":31,"is_primary":false,"text":[{"text":"        pub struct ProcessInfo {","highlight_start":9,"highlight_end":31}],"label":"doesn't satisfy `ProcessInfo: Clone`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`ProcessInfo: Clone`\nwhich is required by `Vec<ProcessInfo>: Clone`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider annotating `ProcessInfo` with `#[derive(Clone)]`","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":6345,"byte_end":6345,"line_start":189,"line_end":189,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"        pub struct ProcessInfo {","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"#[derive(Clone)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `clone` exists for struct `Vec<ProcessInfo>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:698:64\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m189\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         pub struct ProcessInfo {\n    \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m----------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `ProcessInfo: Clone`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m698\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 ProcessTableWidget::new(self.metrics.processes.clone(), self.sort_order)\n    \u001b[1m\u001b[94m|\u001b[0m                                                                \u001b[1m\u001b[91m^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `Vec<ProcessInfo>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `ProcessInfo: Clone`\n            which is required by `Vec<ProcessInfo>: Clone`\n\u001b[1m\u001b[96mhelp\u001b[0m: consider annotating `ProcessInfo` with `#[derive(Clone)]`\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m189\u001b[0m \u001b[92m+ \u001b[0m        \u001b[92m#[derive(Clone)]\u001b[0m\n\u001b[1m\u001b[94m190\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        pub struct ProcessInfo {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no method named `render` found for struct `ProcessTableWidget` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/main.rs","byte_start":25207,"byte_end":25301,"line_start":698,"line_end":699,"column_start":17,"column_end":22,"is_primary":false,"text":[{"text":"                ProcessTableWidget::new(self.metrics.processes.clone(), self.sort_order)","highlight_start":17,"highlight_end":89},{"text":"                    .render(layout.proc_area, f);","highlight_start":1,"highlight_end":22}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":25301,"byte_end":25307,"line_start":699,"line_end":699,"column_start":22,"column_end":28,"is_primary":true,"text":[{"text":"                    .render(layout.proc_area, f);","highlight_start":22,"highlight_end":28}],"label":"method not found in `ProcessTableWidget`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":11391,"byte_end":11397,"line_start":342,"line_end":342,"column_start":16,"column_end":22,"is_primary":false,"text":[{"text":"            fn render(&self, area: Rect, f: &mut Frame);","highlight_start":16,"highlight_end":22}],"label":"the method is available for `ProcessTableWidget` here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":16513,"byte_end":16542,"line_start":482,"line_end":482,"column_start":9,"column_end":38,"is_primary":false,"text":[{"text":"        pub struct ProcessTableWidget {","highlight_start":9,"highlight_end":38}],"label":"method `render` not found for this struct","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"trait `Renderable` which provides `render` is implemented but not in scope; perhaps you want to import it","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":21004,"byte_end":21004,"line_start":595,"line_end":595,"column_start":9,"column_end":9,"is_primary":true,"text":[{"text":"        use crate::errors::SysmonError;","highlight_start":9,"highlight_end":9}],"label":null,"suggested_replacement":"use crate::widgets::Renderable;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: no method named `render` found for struct `ProcessTableWidget` in the current scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/main.rs:699:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               fn render(&self, area: Rect, f: &mut Frame);\n    \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[94m------\u001b[0m \u001b[1m\u001b[94mthe method is available for `ProcessTableWidget` here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m482\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           pub struct ProcessTableWidget {\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[94m-----------------------------\u001b[0m \u001b[1m\u001b[94mmethod `render` not found for this struct\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m698\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m/\u001b[0m                 ProcessTableWidget::new(self.metrics.processes.clone(), self.sort_order)\n\u001b[1m\u001b[94m699\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     .render(layout.proc_area, f);\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod not found in `ProcessTableWidget`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: items from traits can only be used if the trait is in scope\n\u001b[1m\u001b[96mhelp\u001b[0m: trait `Renderable` which provides `render` is implemented but not in scope; perhaps you want to import it\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m595\u001b[0m \u001b[92m+ \u001b[0m        \u001b[92muse crate::widgets::Renderable;\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 28 previous errors; 1 warning emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 28 previous errors; 1 warning emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0061, E0277, E0282, E0308, E0412, E0529, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0061, E0277, E0282, E0308, E0412, E0529, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0061`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0061`.\u001b[0m\n"}
